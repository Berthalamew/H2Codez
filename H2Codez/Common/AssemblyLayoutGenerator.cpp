#include "AssemblyLayoutGenerator.h"
#include "TagDefinitions.h"
#include <boost/property_tree/xml_parser.hpp>
#include <boost/property_tree/ptree.hpp>

using boost::property_tree::ptree;
using boost::property_tree::write_xml;
using boost::property_tree::xml_writer_settings;
using boost::property_tree::xml_writer_make_settings;
using namespace TagDefinitions;

std::map<int, tag_def*> tag_definition_mapping;

size_t get_static_element_size(tag_field::field_type type)
{
	switch (type)
	{
	case tag_field::block:
		return 0xC;
	case tag_field::tag_reference:
		return 0x8;
	case tag_field::word_flags:
	case tag_field::word_block_flags:
		return sizeof(WORD);
	case tag_field::byte_block_flags:
	case tag_field::byte_flags:
	case tag_field::char_block_index1:
	case tag_field::char_integer:
		return sizeof(BYTE);
	case tag_field::real:
	case tag_field::real_fraction:
		return sizeof(float);
	case tag_field::real_ahsv_color:
	case tag_field::real_argb_color:
		return sizeof(colour_rgba);
	case tag_field::string:
		return 0x20  * sizeof(char);
	case tag_field::long_string:
		return 0x100 * sizeof(char);
	default:
		return 0;
	}
}

size_t DumpBlock(ptree &parent_tree, tag_block_defintions *block)
{
	size_t element_offset = 0;

	LOG_FUNC("processing '%s'", block->name);
	
	for (auto fields = block->latest->fields; fields->type != tag_field::terminator; fields++)
	{
		ptree field_tree;
		std::string element_name = "undefined";
		size_t field_size = get_static_element_size(fields->type);

		field_tree.add("<xmlattr>.name", fields->name.get_string());
		field_tree.add("<xmlattr>.offset", element_offset);
		field_tree.add("<xmlattr>.visible", true);

		switch (fields->type) {
			break;
		case tag_field::block:
		{
			element_name = "reflexive";
			auto entry_size = DumpBlock(field_tree, reinterpret_cast<tag_block_defintions*>(fields->defintion));
			field_tree.add("<xmlattr>.entrySize", entry_size);
			break;
		}
		case tag_field::pad:
			field_size = reinterpret_cast<size_t>(fields->defintion);
			break;
		case tag_field::string:
		case tag_field::long_string:
			element_name = "ascii";
		case tag_field::real:
		case tag_field::real_fraction:
			element_name = "float32";
			break;
		case tag_field::tag_reference:
			element_name = "tagRef";
			break;
		case tag_field::explanation:
			element_name = "comment";
			field_tree.add("<xmlattr>.title", fields->name.get_string());
			break;
		default:
			LOG_FUNC("Unhandled field type: %s", tag_field_type_names[fields->type]);
		case tag_field::custom:
			field_tree.add("<xmlattr>.visible", false);
			field_tree.add("<xmlattr>.unsupported_type", tag_field_type_names[fields->type]);
			break;
		}

		element_offset += field_size;
		parent_tree.add_child(element_name, field_tree);
	}

	return element_offset;
}

size_t DumpTag(ptree &parent_tree, tag_def *def)
{
	size_t block_size = 0;
	if (def->parent_group_tag.is_set())
		block_size += DumpTag(parent_tree, tag_definition_mapping[def->parent_group_tag.as_int()]);
	block_size += DumpBlock(parent_tree, def->block_defs);
	return block_size;
}

void DumpPlugin(std::string folder, tag_def *def)
{
	ptree tree;
	ptree &plugin_tree = tree.add("plugin", "");
	plugin_tree.add("<xmlattr>.game", "Halo2");

	ptree &revisions = plugin_tree.add("revisions", "");
	ptree &rev = revisions.add("revision", "Autogenerated by h2codez");
	rev.add("<xmlattr>.author", "IC");
	rev.add("<xmlattr>.version", 1);


	size_t block_size = DumpTag(plugin_tree, def);
	plugin_tree.add("<xmlattr>.baseSize", block_size);

	auto sanitize_filename = [](std::string name) -> std::string {
		constexpr char chars_to_replace[] = { '*', '?', '/', '\\', ':', '"', '|', '>', '<' };
		for (char replace : chars_to_replace)
			std::replace(name.begin(), name.end(), replace, '_');
		return name;
	};

	write_xml(
		folder + sanitize_filename(def->group_tag.as_string()) + ".xml",
		tree,
		std::locale(),
		xml_writer_settings<std::string>('\t', 1)
	);
}

void AssemblyLayoutGenerator::DumpAllTags(std::string folder)
{
	auto tags = TagDefinitions::get_tag_definitions();
	auto tag_count = TagDefinitions::get_tag_count();
	for (size_t i = 0; i < tag_count; i++)
	{
		tag_def *definition = tags[i];
		tag_definition_mapping[definition->group_tag.as_int()] = definition;
	}

	for (size_t i = 0; i < tag_count; i++)
	{
		DumpPlugin(folder, tags[i]);
	}
}
